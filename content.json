[{"title":"Leetcode刷题总结--二叉树","date":"2020-06-11T02:45:10.000Z","path":"2020/06/11/二叉树/","text":"Leetcode刷题总结–二叉树二叉树基础1.满二叉树 ​ 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 2.完全二叉树 ​ 深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k，有n个结点的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树。 ​ 完全二叉树的特点是叶子结点只可能出现在层序最大的两层上，并且某个结点的左分支下子孙的最大层序与右分支下子孙的最大层序相等或大1 3.二叉搜索树（Binary Search Tree） ​ BST最大的特点就是，左子树&lt;根&lt;右子树，中序遍历为有序序列。 4.自平衡二叉搜索树(AVL树) AVL树最大的特点就是： 本身首先是一棵二叉搜索树 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1 二叉树的基础代码1.二叉树的遍历（中序遍历）1234567891011121314151617//中序遍历 前序后序同理public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorderTraversal(root, list); return list;&#125;public void inorderTraversal(TreeNode root,List&lt;Integer&gt; list) &#123; if(root!=null)&#123; if(root.left!=null)&#123; inorderTraversal(root.left,list); &#125; list.add(root.val); if(root.right!=null)&#123; inorderTraversal(root.right,list); &#125; &#125;&#125; 2.二叉树的层序遍历1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); levelOrder(root,res); return res;&#125;public void levelOrder(TreeNode root,List&lt;List&lt;Integer&gt;&gt; res) &#123; Queue&lt;treeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode cur = queue.poll(); //if(cur==null) continue; 看是否输出空节点 //if(cur==null) list.add(null); 空节点无法调用.val list.add(cur.val); queue.offer(cur.left); queue.offer(cur.right); &#125; if(!list.isEmpty()) res.add(list); &#125;&#125; 3.二叉树的前驱节点对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点 1234567891011121314151617181920212223242526public TreeNode findPreNode(TreeNode node)&#123; if(node==null) return node; TreeNode preNode = new TreeNode(-1); //有左子树，则找左子树的最右 if(node.left!=null)&#123; preNode = findRight(node.left); &#125;else&#123; //无左子树，则找左父节点 preNode = findLeftParent(node); &#125; return preNode;&#125;//找最右private TreeNode findRight(TreeNode node)&#123; while(node.right!=null)&#123; node = node.right; &#125; return node;&#125;//找左父节点private TreeNode findLeftParent(TreeNode node)&#123; while(node.parent!=null &amp;&amp; node.parent.right!=node)&#123; node = node.parent; &#125; return node;&#125; 4.二叉树的后继节点对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点","tags":[{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Leetcode刷题联想总结","date":"2020-06-10T02:45:10.000Z","path":"2020/06/10/Leetcode刷题联想总结/","text":"Leetcode刷题联想总结 数组（排序、双指针、三指针、扫描方向&lt;左-&gt;右、右-&gt;左&gt;） 链表（虚拟头结点、新串链表、双指针、快慢指针、翻转、中间节点、删除节点） 二叉树（前中后序遍历、递归） 排列组合（DFS） 最值（动态规划） 对称/顺序（栈/队列、单调栈） 部分核心框架代码链表（虚拟头结点+新串链表）12345678910ListNode dummyHead = new ListNode(0);//虚拟头结点ListNode cur = dummyHead;//新串链表while()&#123; //逻辑业务... //新串链表 cur.next = new ListNode(val); cur = cur.next;&#125;return dummyHead.next; 链表（快慢指针找中间节点）12345678ListNode fast = head;ListNode low = head;while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; low = low.next;&#125;//返回的low为中间节点return low; 链表（哨兵节点+反转链表）12345678910111213141516public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode temp = null; ListNode cur = head; while(cur!=null)&#123; //记录下一个节点 temp = cur.next; //指向前节点 cur.next = pre; //更新前节点 pre = cur; //操作下一个节点 cur = temp; &#125; return per;&#125; 链表（删除节点=当前节点赋值下一个节点的val+当前节点指向下一个节点的next）1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125; 单调栈739.每日温度 123456789101112131415161718192021public int[] dailyTemperatures(int[] T) &#123; if (T == null || T.length == 0) return null; int[] result = new int[T.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); /** * 1.站内空入栈 * 2.比栈内大，出栈再比较, 出栈元素的天数等于索引-索引 * 3.比栈内小，则入栈 */ for (int i = 0; i &lt; T.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123; Integer pop = stack.pop(); result[pop] = i - pop; &#125; if (stack.isEmpty()) stack.push(i); else if (T[i] &lt;= T[stack.peek()]) stack.push(i); &#125; return result;&#125;","tags":[]},{"title":"HashMap结构与底层实现","date":"2020-02-15T02:45:10.000Z","path":"2020/02/15/HashMap/","text":"1 HashMap的结构​ HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。 1.1 JDK1.7 HashMap结构与实现（数组+链表） 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 1.2 JDK1.8 HashMap结构与实现（数组+链表+红黑树）​ Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树组成。 ​ 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍 –默认16 loadFactor：负载因子，默认为 0.75 threshold：扩容的阈值，等于 capacity * loadFactor 2 ConcurrentHashMap的结构与实现2.1 Segment段ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。 2.2 线程安全（Segment继承 ReentrantLock 加锁）简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 2.3 JDK1.7 ConcurrentHashMap结构与实现 concurrencyLevel（并发度）：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 2.4 JDK1.8 ConcurrentHashMap结构与实现Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 主要改进CAS无锁算法与synchronized保证并发安全，支持并发扩容，数据结构变更为数组+链表+红黑树，提高性能。 jdk1.8版弃用变量Segment 只有序列化时会用到。 loadFactor 仅用于构造函数中设定初始容量，已不能影响扩容阈值，jdk1.8版本中阈值计算基本恒定为0.75。 concurrencyLevel 只能影响初始容量，table容量大小与它无关。","tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://yoursite.com/tags/HashMap/"}]},{"title":"Java异常处理","date":"2020-02-10T02:45:10.000Z","path":"2020/02/10/Java异常处理/","text":"1 Java异常处理1.1 异常类的层次结构​ 异常不管叫啥名名字，它只能发生在运行的阶段。 Error:​ 在 Java 中只要 Error 发生了就一种结果——退出 JVM，例如 StackOverError。 Exception 的直接子类：​ Exception 的直接子类叫做编译时异常、受控异常、检查异常。它虽然叫做编译时异常，但是它不是发生在编译阶段的异常，之所以叫做编译时异常是因为编译时异常要求必须在程序编译的阶段就手动的处理，如果不处理这些异常的话，程序无法编译通过。 RuntimeException​ RuntimeException 的直接子类叫做运行时异常、非受控异常、非检查异常。这种异常不要求在程序编译阶段处理，编译也可以通过。 自定义异常：​ JDK 提供的异常不能够满足要求的情况下用户可以自己自定义异常，可以根据实际情况选择继承Exception 或者 RuntimeException 两种形式。 1.2 异常的分类​ 通过上一节的介绍我们了解到异常主要分为：错误、一般性异常（受控异常）、运行期异常（非受控异常）。 错误：如果应用程序出现了 Error，那么将无法恢复，只能重新启动应用程序，最典型的 Error 的异常是：OutOfMemoryError 受控异常：出现了这种异常必须显示的处理，不显示处理 java 程序将无法编译通过 非受控异常：此种异常可以不用显示的处理，例如被 0 除异常，java 没有要求我们一定要处理 2 异常的处理遇到异常，就要求我们处理来处理，处理异常有两种方式： 采用 try 、catch、finally 来捕获异常 遇到异常时自己不捕获，而是将异常对象抛给调用者，语法是在在方法声明位置上使用 throws 关键字 2.1 捕获异常try、catch、finally123456789try&#123;&#125;catch(OneException)&#123;&#125;catch(TwoException)&#123;&#125;finally&#123;&#125; try 中包含了可能产生异常的代码 try 后面是 catch，catch 可以有一个或多个，catch 中是需要捕获的异常 当 try 中的代码出现异常时，出现异常下面的代码不会执行，马上会跳转到相应的 catch 语句块中，如果没有异常不会跳转到 catch 中 finally 表示，不管是出现异常，还是没有出现异常，finally 里的代码都执行，finally 和 catch 可以分开使用，但 finally 必须和 try 一块使用，如下格式使用 finally 也是正确的 2.2 自定义异常自定义异常通常继承于 Exception 或 RuntimeException，到底继承那个应该看具体情况来定。异常的捕获顺序应该是：从小到大 1234567891011public class MyException extends RuntimeException &#123; //定义无参构造方法 public MyException() &#123; super(); &#125; //定义有参构造方法 public MyException(String message) &#123; super(message); &#125;&#125;","tags":[{"name":"异常处理","slug":"异常处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"springboot+vue前后端分离12--两种文件上传","date":"2020-01-15T02:45:10.000Z","path":"2020/01/15/springboot+vue前后端分离12--两种文件上传/","text":"文件上传在Vue.js 中，如果网络请求使用 axios ，并且使用了 ElementUI 库，那么一般来说，文件上传有两种不同的实现方案： 通过 Ajax 实现文件上传 通过 ElementUI 里边的 Upload 组件实现文件上传接口准备12345678910111213141516SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;&#x2F;yyyy&#x2F;MM&#x2F;dd&#x2F;&quot;);@PostMapping(&quot;&#x2F;import&quot;)public RespBean importData(MultipartFile file, HttpServletRequest req) throws IOException &#123; String format &#x3D; sdf.format(new Date()); String realPath &#x3D; req.getServletContext().getRealPath(&quot;&#x2F;upload&quot;) + format; File folder &#x3D; new File(realPath); if (!folder.exists()) &#123; folder.mkdirs(); &#125; String oldName &#x3D; file.getOriginalFilename(); String newName &#x3D; UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;)); file.transferTo(new File(folder,newName)); String url &#x3D; req.getScheme() + &quot;:&#x2F;&#x2F;&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + &quot;&#x2F;upload&quot; + format + newName; System.out.println(url); return RespBean.ok(&quot;上传成功!&quot;);&#125; 这里的文件上传比较简单，上传的文件按照日期进行归类，使用 UUID 给文件重命名。 这里为了简化代码，我省略掉了异常捕获，上传结果直接返回成功，后端代码可根据实际情况自行修改。 1.Ajax 上传在 Vue 中，通过 Ajax 实现文件上传，方案和传统 Ajax 实现文件上传基本上是一致的，唯一不同的是查找元素的方式。 12&lt;input type&#x3D;&quot;file&quot; ref&#x3D;&quot;myfile&quot;&gt;&lt;el-button @click&#x3D;&quot;importData&quot; type&#x3D;&quot;success&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-upload2&quot;&gt;导入数据&lt;&#x2F;el-button&gt; 在这里，首先提供一个文件导入 input 组件，再来一个导入按钮，在导入按钮的事件中来完成导入的逻辑。 123456789101112importData() &#123; let myfile &#x3D; this.$refs.myfile; let files &#x3D; myfile.files; let file &#x3D; files[0]; var formData &#x3D; new FormData(); formData.append(&quot;file&quot;, file); this.uploadFileRequest(&quot;&#x2F;system&#x2F;basic&#x2F;jl&#x2F;import&quot;,formData).then(resp&#x3D;&gt;&#123; if (resp) &#123; console.log(resp); &#125; &#125;)&#125; 文件上传注意两点，1. 请求方法为 post，2. 设置 Content-Type 为 multipart/form-data 。 封装的请求方法 12345678910export const uploadFileRequest &#x3D; (url, params) &#x3D;&gt; &#123; return axios(&#123; method: &#39;post&#39;, url: &#96;$&#123;base&#125;$&#123;url&#125;&#96;, data: params, headers: &#123; &#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39; &#125; &#125;);&#125; 2.使用 Upload 组件如果使用 Upload ，则需要引入 ElementUI，所以一般建议，如果使用了 ElementUI 做 UI 控件的话，则可以考虑使用 Upload 组件来实现文件上传，如果没有使用 ElementUI 的话，则不建议使用 Upload 组件，至于其他的 UI 控件，各自都有自己的文件上传组件，具体使用可以参考各自文档。 123456789&lt;el-upload style&#x3D;&quot;display: inline&quot; :show-file-list&#x3D;&quot;false&quot; :on-success&#x3D;&quot;onSuccess&quot; :on-error&#x3D;&quot;onError&quot; :before-upload&#x3D;&quot;beforeUpload&quot; action&#x3D;&quot;&#x2F;system&#x2F;basic&#x2F;jl&#x2F;import&quot;&gt; &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;success&quot; :disabled&#x3D;&quot;!enabledUploadBtn&quot; :icon&#x3D;&quot;uploadBtnIcon&quot;&gt;&#123;&#123;btnText&#125;&#125;&lt;&#x2F;el-button&gt;&lt;&#x2F;el-upload&gt; 相应的回调如下： 123456789101112131415onSuccess(response, file, fileList) &#123; this.enabledUploadBtn &#x3D; true; this.uploadBtnIcon &#x3D; &#39;el-icon-upload2&#39;; this.btnText &#x3D; &#39;数据导入&#39;;&#125;,onError(err, file, fileList) &#123; this.enabledUploadBtn &#x3D; true; this.uploadBtnIcon &#x3D; &#39;el-icon-upload2&#39;; this.btnText &#x3D; &#39;数据导入&#39;;&#125;,beforeUpload(file) &#123; this.enabledUploadBtn &#x3D; false; this.uploadBtnIcon &#x3D; &#39;el-icon-loading&#39;; this.btnText &#x3D; &#39;正在导入&#39;;&#125; 在文件开始上传时，修改上传按钮为不可点击，同时修改上传按钮的图标和文本。 文件上传成功或者失败时，修改上传按钮的状态为可以点击，同时恢复上传按钮的图标和文本。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离11--项目模块化改造","date":"2020-01-13T02:45:10.000Z","path":"2020/01/13/springboot+vue前后端分离11--项目模块化改造/","text":"项目模块化改造一、项目结构vhr =&gt; 爷模块 —mailserver =&gt; 父模块1(邮件模块) —vhrserver =&gt; 父模块2(管理模块) ——vhr-mapper =&gt; 持久层模块 ——vhr-model =&gt; 实体模型模块 ——vhr-service =&gt; 服务层模块 ——vhr-web =&gt; 控制层模块 二、整理依赖关系1.父子关系pom.xml(vhr) 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;...&lt;modules&gt; &lt;module&gt;vhrserver&lt;&#x2F;module&gt; &lt;module&gt;mailserver&lt;&#x2F;module&gt;&lt;&#x2F;modules&gt; pom.xml(mailserver) 12345&lt;parent&gt; &lt;artifactId&gt;vhr&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; pom.xml(vhrserver) 123456789101112&lt;parent&gt; &lt;artifactId&gt;vhr&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;...&lt;modules&gt; &lt;module&gt;vhr-mapper&lt;&#x2F;module&gt; &lt;module&gt;vhr-model&lt;&#x2F;module&gt; &lt;module&gt;vhr-service&lt;&#x2F;module&gt; &lt;module&gt;vhr-web&lt;&#x2F;module&gt;&lt;&#x2F;modules&gt; pom.xml(vhr-mapper) 12345&lt;parent&gt; &lt;artifactId&gt;vhrserver&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; pom.xml(vhr-model) 12345&lt;parent&gt; &lt;artifactId&gt;vhrserver&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; pom.xml(vhr-service) 12345&lt;parent&gt; &lt;artifactId&gt;vhrserver&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; pom.xml(vhr-web) 12345&lt;parent&gt; &lt;artifactId&gt;vhrserver&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt; 2.依赖关系mapper依赖model 12345&lt;dependency&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;artifactId&gt;vhr-model&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; service依赖mapper 12345&lt;dependency&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;artifactId&gt;vhr-mapper&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; web依赖service、mapper 12345678910&lt;dependency&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;artifactId&gt;vhr-service&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.tsune&lt;&#x2F;groupId&gt; &lt;artifactId&gt;vhr-mapper&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 3.clean和install各个模块==注意：==首先clean和install父模块；然后先clean和install没有依赖的模块，再clean和install有依赖的模块（其依赖的模块必须先进行clean和install，否则会依赖管理打包faild）;两个模块不能相互加入依赖模块坐标，会报循环调用错误。（有相互依赖的情况下将两个模块合并写成一个模块） （当install一个模块，maven发现模块内依赖其他模块jar，maven会在本地仓库中寻找该jar，找不到自然会报错。install作用就是将模块打包成jar记录在本地仓库供依赖模块使用） ==注意：== 每次修改完代码后需要调试时，需要将本module重新clean和install成可供其他模块依赖的jar。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离10--Docker与rabbitmq","date":"2020-01-11T02:45:10.000Z","path":"2020/01/11/springboot+vue前后端分离10--Docker与rabbitmq/","text":"DockerDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。Docker的安装参考Docker安装不再展开RabbitMQRabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。使用Docker的安装RabbitMQ在Docker Hub上搜索rabbitmq使用以下命令安装rabbitmq，在标准管理端口15672上使用，默认用户名和密码为guest / guest可以在–name some-rabbit这里对rabbitmq重命名为–name tsune-rabbit 1docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3-management 安装完成查看运行状态 1docker ps 运行成功可以使用guest用户访问默认端口localhost:15672 SpringBoot整合rabbitmq添加AMQP与thymeleaf模板依赖pom.xml 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 配置application.properties 123456789101112131415161718server.port&#x3D;8082spring.mail.host&#x3D;smtp.qq.comspring.mail.protocol&#x3D;smtpspring.mail.default-encoding&#x3D;utf-8&#x2F;&#x2F;发送邮箱的usernamespring.mail.username&#x3D;874128058@qq.com&#x2F;&#x2F;发送邮箱的passwordspring.mail.password&#x3D;ihtgjoumktzlbdicspring.mail.port&#x3D;587spring.mail.properties.mail.stmp.socketFactory.class&#x3D;javax.net.ssl.SSLSocketFactoryspring.mail.properties.mail.debug&#x3D;true&#x2F;&#x2F;rabbitmq配置spring.rabbitmq.username&#x3D;guestspring.rabbitmq.password&#x3D;guestspring.rabbitmq.host&#x3D;localhostspring.rabbitmq.port&#x3D;5672 配置MailserverApplication 12345678910111213@SpringBootApplicationpublic class MailserverApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MailserverApplication.class, args); &#125; &#x2F;&#x2F;创建rabbitmq监听队列监听tsune.mail.welcome @Bean Queue queue()&#123; return new Queue(&quot;tsune.mail.welcome&quot;); &#125;&#125; 创建配置MailReceiver 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class MailReceiver &#123; &#x2F;&#x2F;监听日志 public static final Logger logger &#x3D; LoggerFactory.getLogger(MailReceiver.class); @Autowired JavaMailSender javaMailSender; @Autowired MailProperties mailProperties; @Autowired TemplateEngine templateEngine; &#x2F;&#x2F;监听队列 @RabbitListener(queues &#x3D; &quot;tsune.mail.welcome&quot;) public void handler(Employee employee)&#123; &#x2F;&#x2F;日志 logger.info(employee.toString()); &#x2F;&#x2F;收到消息，发送邮件 MimeMessage mimeMessage &#x3D; javaMailSender.createMimeMessage(); MimeMessageHelper helper &#x3D; new MimeMessageHelper(mimeMessage); try &#123; helper.setTo(employee.getEmail()); helper.setFrom(mailProperties.getUsername()); helper.setSubject(&quot;入职欢迎&quot;); helper.setSentDate(new Date()); &#x2F;&#x2F;设置thymeleaf模板context属性 Context context &#x3D; new Context(); context.setVariable(&quot;name&quot;,employee.getName()); context.setVariable(&quot;posName&quot;,employee.getPosition().getName()); context.setVariable(&quot;joblevelName&quot;,employee.getJoblevel().getName()); context.setVariable(&quot;departmentName&quot;,employee.getDepartment().getName()); &#x2F;&#x2F;将context映射到mail.html String mail &#x3D; templateEngine.process(&quot;mail&quot;, context); helper.setText(mail,true); &#x2F;&#x2F;发送邮件 javaMailSender.send(mimeMessage); &#125; catch (MessagingException e) &#123; e.printStackTrace(); logger.error(&quot;邮件发送失败&quot;+e.getMessage()); &#125; &#125;&#125; mail.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;入职欢迎邮件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;欢迎&lt;span th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;span&gt; 加入 tsune 大家庭，您的入职信息如下：&lt;table border&#x3D;&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;职位&lt;&#x2F;td&gt; &lt;td th:text&#x3D;&quot;$&#123;posName&#125;&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;&#x2F;td&gt; &lt;td th:text&#x3D;&quot;$&#123;joblevelName&#125;&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;&#x2F;td&gt; &lt;td th:text&#x3D;&quot;$&#123;departmentName&#125;&quot;&gt;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;p&gt;希望在未来的日子里携手共进&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; controller层 12345678910@PostMapping(&quot;&#x2F;&quot;)public RespBean addEmp(@RequestBody Employee employee) &#123; if (employeeMapper.insertSelective(employee) &#x3D;&#x3D; 1) &#123; Employee emp &#x3D; employeeMapper.getEmployeeById(employee.getId()); &#x2F;&#x2F;插入成添加队列queue&#x3D;&quot;tsune.mail.welcome&quot; 进行发送 rabbitTemplate.convertAndSend(&quot;tsune.mail.welcome&quot;,emp); return RespBean.ok(&quot;添加成功&quot;); &#125; return RespBean.ok(&quot;添加失败&quot;);&#125; 效果","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离9--整合WebSocket","date":"2020-01-10T02:45:10.000Z","path":"2020/01/10/springboot+vue前后端分离9--整合WebSocket/","text":"spingboot整合WebSocketWebSocket在WebSocket概念出来之前，如果页面要不停地显示最新的价格，那么必须不停地刷新页面，或者用一段js代码每隔几秒钟发消息询问服务器数据。 而使用WebSocket技术之后，当服务器有了新的数据，会主动通知浏览器。 可用于 在线股票网站 即时聊天 多人在线游戏 应用集群通信 系统性能实时监测 …整合WebSocket1.添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置WebSocket配置前端SockJS关联的url—-配置消息代理的前缀12345678910111213141516@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123; @Override public void registerStompEndpoints(StompEndpointRegistry registry) &#123; //配置与前端SockJS关联的url //setAllowedOrigins(\"*\")表示SpringSecurity请求放行 registry.addEndpoint(\"/ws/ep\").setAllowedOrigins(\"*\").withSockJS(); &#125; @Override public void configureMessageBroker(MessageBrokerRegistry registry) &#123; //配置消息代理的前缀 registry.enableSimpleBroker(\"/queue\"); &#125;&#125; 3.配置Controller先接受消息发送请求,得知From，to，msg，再通过simpMessagingTemplate.convertAndSendToUser实现点对点发消息12345678910111213141516171819@Controllerpublic class WsController &#123; @Autowired //点对点发消息用SimpMessagingTemplate来实现 SimpMessagingTemplate simpMessagingTemplate; //接收前端chatMsg内有要发给谁chatMsg.getTo() @MessageMapping(\"/ws/chat\") public void handleMsg(Authentication authentication, ChatMsg chatMsg)&#123; //获取当前对象 Hr hr = (Hr) authentication.getPrincipal(); //设置发消息的From与发消息的Date chatMsg.setFrom(hr.getUsername()); chatMsg.setFromNickname(hr.getName()); chatMsg.setDate(new Date()); //通过simpMessagingTemplate.convertAndSendToUser将消息发送出去 //convertAndSendToUser(user, destination, (MessagePostProcessor) null); simpMessagingTemplate.convertAndSendToUser(chatMsg.getTo(),\"/queue/chat\",chatMsg); &#125; 4.前端建立连接安装工具类stompjs与sockjs-client12npm install stompjsnpm install sockjs-client 导入12import Stomp from &#39;stompjs&#39;import SockJS from &#39;sockjs-client&#39;; 建立连接Sstore/index.js12345678910111213141516actions: &#123; connect(context) &#123; context.state.stomp &#x3D; Stomp.over(new SockJS(&#39;&#x2F;ws&#x2F;ep&#39;)); context.state.stomp.connect(&#123;&#125;, success &#x3D;&gt; &#123; &#x2F;&#x2F;连接成功后订阅地址&#39;&#x2F;user&#x2F;queue&#x2F;chat&#39; &#x2F;&#x2F;user为SimpMessagingTemplate类自动添加了路径前缀 context.state.stomp.subscribe(&#39;&#x2F;user&#x2F;queue&#x2F;chat&#39;, msg &#x3D;&gt; &#123; let receiveMsg &#x3D; JSON.parse(msg.body); receiveMsg.notSelf &#x3D; true; receiveMsg.to &#x3D; receiveMsg.from; &#x2F;&#x2F;通过addMessage发动 context.commit(&#39;addMessage&#39;, receiveMsg); &#125;) &#125; &#125; &#125; addMessage12345678910111213mutations:&#123; addMessage(state, msg) &#123; let mss &#x3D; state.sessions[state.currentHr.username + &#39;#&#39; + msg.to]; if (!mss) &#123; Vue.set(state.sessions, state.currentHr.username + &#39;#&#39; + msg.to[]); &#125; state.sessions[state.currentHr.username + &#39;#&#39; + msg.to].push(&#123; content: msg.content, date: new Date(), self: !msg.notSelf &#125;) &#125;,&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离8--Excel导入导出解析","date":"2020-01-09T01:45:10.000Z","path":"2020/01/09/springboot+vue前后端分离8--Excel导入导出解析/","text":"Excel导入导出及解析POI工具依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.1&lt;/version&gt;&lt;/dependency&gt; Excel导出1.创建工具类POIUtils将员工信息导出为Excelemployee2Excel12345public class POIUtils &#123; public static ResponseEntity&lt;byte[]&gt; employee2Excel(List&lt;Employee&gt; list) &#123; &#x2F;&#x2F;具体代码见后面 &#125;&#125; 2.创建一个Excel文档并设置全局要用的格式123456789&#x2F;&#x2F;1、创建一个Excel文档workbookHSSFWorkbook workbook &#x3D; new HSSFWorkbook();&#x2F;&#x2F;2、设置标题栏颜色HSSFCellStyle headerStyle &#x3D; workbook.createCellStyle();headerStyle.setFillForegroundColor(IndexedColors.YELLOW.index);headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);&#x2F;&#x2F;3、创建单元格非string(本例日期)的特殊格式HSSFCellStyle dateCellStyle &#x3D; workbook.createCellStyle();dateCellStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat(&quot;m&#x2F;d&#x2F;yy&quot;)); 3.创建Excel的一个sheet表单1234567891011121314&#x2F;&#x2F;创建表单HSSFSheet sheet &#x3D; workbook.createSheet(&quot;员工信息表&quot;);&#x2F;&#x2F;创建标题行HSSFRow r0 &#x3D; sheet.createRow(0);&#x2F;&#x2F;设置标题行样式r0.setRowStyle(headerStyle);&#x2F;&#x2F;创建第一行第一列单元格HSSFCell c0 &#x3D; r0.createCell(0);&#x2F;&#x2F;设置1-1单元格的值c0.setCellValue(&quot;编号&quot;);&#x2F;&#x2F;创建第一行第二列单元格HSSFCell c1 &#x3D; r0.createCell(1);c1.setCellValue(&quot;姓名&quot;);&#x2F;&#x2F;.....以此类推 4.将数据写入sheet表单1234567891011121314151617for (int i = 0; i &lt; list.size(); i++) &#123; //读取对象 Employee emp = list.get(i); //创建标题栏之后的行 HSSFRow row = sheet.createRow(i + 1); //创建单元格并写入值 row.createCell(0).setCellValue(emp.getId()); row.createCell(1).setCellValue(emp.getName()); row.createCell(2).setCellValue(emp.getWorkid()); //创建单元格 HSSFCell cell3 = row.createCell(3); //设置单元格为日期类型 cell3.setCellStyle(dateCellStyle); //写入生日数据 cell3.setCellValue(emp.getBirthday()); //.....以此类推｝ 5.创建输出流将wrokbook Excel输出1234567891011121314151617//创建baos输出流ByteArrayOutputStream baos = new ByteArrayOutputStream();//创建headersHttpHeaders headers=new HttpHeaders();try &#123; //设置headers headers.setContentDispositionFormData(\"attachment\",neString(\"员工表.xls\".getBytes(\"UTF-8\"),\"ISO-8859-1\")); //将设置headers的媒体类为下载 headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); //将workbook写入baos输出流 workbook.write(baos);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;return new ResponseEntity&lt;byte[]&gt;(baos.toByteArray(),headersHttpStatus.CREATED);&#125;&#125; Excel导出1.创建工具类POIUtils将Excel解析excel2Employee12345public class POIUtils &#123; public static List&lt;Employee&gt; excel2Employee(MultipartFile file, List&lt;Nation&gt; allNations, List&lt;Politicsstatus&gt; allPoliticsstatus, List&lt;Department&gt; allDepartments, List&lt;Position&gt; allPositions, List&lt;Joblevel&gt; allJobLevels) &#123; //具体代码见后面 &#125;&#125; 2.创建workbook=&gt;循环解析sheet表单=&gt;循环解析表单中的行12345678910111213141516171819202122//1. 创建一个 workbook 对象HSSFWorkbook workbook = new HSSFWorkbook(file.getInputStream());//2. 获取 workbook 中表单的数量int numberOfSheets = workbook.getNumberOfSheets();for (int i = 0; i &lt; numberOfSheets; i++) &#123; //3. 获取表单 HSSFSheet sheet = workbook.getSheetAt(i); //4. 获取表单中的行数 int physicalNumberOfRows = sheet.getPhysicalNumberOfRows(); for (int j = 0; j &lt; physicalNumberOfRows; j++) &#123; //5. 跳过标题行 if (j == 0) &#123; continue;//跳过标题行 &#125; //6. 获取行 HSSFRow row = sheet.getRow(j); if (row == null) &#123; continue;//防止数据中间有空行 &#125; //7. 获取列数 int physicalNumberOfCells = row.getPhysicalNumberOfCells(); employee = new Employee(); =&gt;循环解析行中的列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657for (int k = 0; k &lt; physicalNumberOfCells; k++) &#123; HSSFCell cell = row.getCell(k); switch (cell.getCellType()) &#123; //单元格为String类型 case STRING: //获取单元格的值cellValue String cellValue = cell.getStringCellValue(); //根据第几列来对employee对象赋值 switch (k) &#123; case 1: employee.setName(cellValue); break; case 2: employee.setWorkid(cellValue); break; case 3: employee.setGender(cellValue); break; case 5: employee.setIdcard(cellValue); break; case 6: employee.setWedlock(cellValue); break; case 7: //根据单元格的nation的name来获取allNations里的index int nationIndex = allNations.indexOf(Nation(cellValue)); //根据index获取带有id信息的nation,将nationid赋值给employee对象 employee.setNationid(allNations.get(natndex).getId()); break; //...依次类推 &#125; break; //单元格为日期类型...依次类推 default: &#123; //根据单元格位置给employee赋值 switch (k) &#123; case 4: employee.setBirthday(cell.getDateCellValue); break; //...依次类推 &#125; &#125; break; &#125; //将读取的一个employee添加到list中 list.add(employee);&#125;&#125;&#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; return list;&#125;&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离7--mybatis数据传递实现分页","date":"2020-01-07T11:01:10.000Z","path":"2020/01/07/springboot+vue前后端分离7--mybatis数据传递实现分页/","text":"mybatis数据传递@Param 多参数实现分页@Param注解：dao层与xml映射时参数有多个时分页：sql使用 limit page,size 来控制分页，其中page为显示该参数下一条数据开始，size为每次返回的数据条数。示例RespPageBean工具类 12345public class RespPageBean &#123; private Long total; private List&lt;?&gt; data; //省略get、set&#125; controller层 12345678910111213@GetMapping(\"/\") public RespPageBean getEmployeeByPage(@RequestParam(defaultValue = \"1\") Integer page, @RequestParam(defaultValue = \"10\") Integer size, String keywords) &#123; //计算页数与开始数据的关系 if (page != null &amp;&amp; size != null) &#123; page = (page - 1) * size; &#125; List&lt;Employee&gt; data = employeeMapper.getAllEmpInfo(page, size, keywords); Long total = employeeMapper.getTotal(keywords); RespPageBean respPageBean = new RespPageBean(); respPageBean.setData(data); respPageBean.setTotal(total); return respPageBean; &#125; EmployeeMapper.javadao层示例 123public interface EmployeeMapper &#123; List&lt;Employee&gt; getAllEmpInfo(@Param(&quot;page&quot;) Integer page, @Param(&quot;size&quot;) Integer size, @Param(&quot;keywords&quot;) String keywords);&#125; EmployeeMapper.xml xml映射对应示例 123456789&lt;select id&#x3D;&quot;getAllEmpInfo&quot; resultMap&#x3D;&quot;AllEmpInfo&quot;&gt; SELECT * FROM employee &lt;if test&#x3D;&quot;keywords !&#x3D;null and keywords !&#x3D;&#39;&#39;&quot;&gt; AND e.name like concat(&#39;%&#39;,#&#123;keywords&#125;,&#39;%&#39;) &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;page!&#x3D;null and size!&#x3D;null&quot;&gt; limit #&#123;page&#125;,#&#123;size&#125; &lt;&#x2F;if&gt;&lt;&#x2F;select&gt; 一对多示例多级目录 1 1.1 1.1.1 1.1.2 1.2 2 3 步骤1Menu类添加List集合private List&lt;Menu&gt; children 123456public class Menu &#123; private Integer id; private String url; ... private List&lt;Menu&gt; children;&#125; 步骤2MenuMapper.xml1.添加resultMap 1234567891011121314151617&lt;!-- 3级菜单目录 --&gt;&lt;resultMap id=\"MenuWithChildren\" type=\"com.tsune.vhr02.entity.Menu\" extends=\"MyBaseResultMap\"&gt; &lt;id column=\"id1\" property=\"id\"/&gt; &lt;result column=\"name1\" property=\"name\"/&gt; &lt;!-- 一对多的关系 --&gt; &lt;!-- property: 指的是List集合的值, ofType：指的是集合中元素的类型 --&gt; &lt;collection property=\"children\" ofType=\"com.tsune.vhr02.entity.Menu\"&gt; &lt;id column=\"id2\" property=\"id\"/&gt; &lt;result column=\"name2\" property=\"name\"/&gt; &lt;!-- 一对多的关系 --&gt; &lt;!-- property: 指的是List集合的值, ofType：指的是集合中元素的类型 --&gt; &lt;collection property=\"children\" ofType=\"com.tsune.vhr02.entity.Menu\"&gt; &lt;id column=\"id3\" property=\"id\"/&gt; &lt;result column=\"name3\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; 2.sql查询 123&lt;select id=\"getAllMenus\" resultMap=\"MenuWithChildren\"&gt; select m1.`id` as id1,m1.`name` as name1,m2.`id` as id2,m2.`name` as name2,m3.`id` as id3,m3.`name` as name3 from menu m1,menu m2,menu m3 where m1.`id`=m2.`parentId` and m2.`id`=m3.`parentId` and m3.`enabled`=true order by m1.`id`,m2.`id`,m3.`id`&lt;/select&gt; 插入成功返回自增属性在插入时数据是不带有自增属性的值，比如自增主键id，而我们又需要get到插入成功后该数据的id，就需要插入成功后再使用该对象时，该对象具有id值 方法在mapper.xml中使用：useGeneratedKeys=”true” keyProperty=”id” 123&lt;insert id=\"insertSelective\" parameterType=\"com.tsune.vhr02.entity.Employee\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; 插入操作的sql语句&lt;/insert&gt; 如果插入成功即可通过主键get到带有主键id数据的插入对象 123if (employeeMapper.insertSelective(employee) &#x3D;&#x3D; 1) &#123; Employee emp &#x3D; employeeMapper.getEmployeeById(employee.getId()); ｝","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离6--后端请求响应工具类封装","date":"2020-01-05T01:11:10.000Z","path":"2020/01/05/springboot+vue前后端分离6--后端请求响应工具类封装/","text":"后端请求响应工具类封装RespBean 请求返回 服务器响应码 status 自定义返回消息 msg 自定义对象obj RespBean.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class RespBean &#123; private Integer status; private String msg; private Object obj; public static RespBean ok(String msg)&#123; return new RespBean(200,msg,null); &#125; public static RespBean ok(String msg, Object obj)&#123; return new RespBean(200,msg,obj); &#125; public static RespBean error(String msg)&#123; return new RespBean(500,msg,null); &#125; public static RespBean error(String msg, Object obj)&#123; return new RespBean(500,msg,obj); &#125; public static RespBean build()&#123; return new RespBean(); &#125; private RespBean() &#123; &#125; private RespBean(Integer status, String msg, Object obj) &#123; this.status = status; this.msg = msg; this.obj = obj; &#125; public Integer getStatus() &#123; return status; &#125; public RespBean setStatus(Integer status) &#123; this.status = status; return this; &#125; public String getMsg() &#123; return msg; &#125; public RespBean setMsg(String msg) &#123; this.msg = msg; return this; &#125; public Object getObj() &#123; return obj; &#125; public RespBean setObj(Object obj) &#123; this.obj = obj; return this; &#125;&#125; 示例 1234567@PutMapping(\"/\")public RespBean updateHr(@RequestBody Hr hr)&#123; if (hrMapper.updateByPrimaryKeySelective(hr)==1)&#123; return RespBean.ok(\"更新成功\"); &#125; return RespBean.error(\"更新失败\");&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离5--数据校验","date":"2020-01-02T07:11:10.000Z","path":"2020/01/02/springboot+vue前后端分离5--数据校验/","text":"关于前后端数据校验校验原则必须在后端校验的唯一性验证，验证码，敏感词，出错概率高的要做异步校验。 后端校验可以防止接口被私自调用导致破坏数据库结构；避免有人模拟浏览器行为（如postman等工具）直接给服务器发请求。 有必要在前端校验的必填项、（邮箱、电话号、地址）格式、密码强度检测。 前端校验便于用户纠正（快速反馈），并且减少服务器压力、节省流量（减少无意义的请求），主要对用户友好。 比如手机号码，邮箱号不合法，或者密码强度太弱，在前端校验可以不等后端返回，直接提醒用户不合法，让用户及时知晓并更改，避免不必要的提交，再等待服务器返回错误信息。 前端表单验证示例Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。element-ui的Form校验示例 附正则表达式在线测试|菜鸟工具 12345678910rules: &#123; &#x2F;&#x2F;普通校验 birthday: [&#123;required: true, message: &#39;请输入出生日期&#39;, trigger: &#39;blur&#39;&#125;], &#x2F;&#x2F;正则校验 idcard: [&#123;required: true, message: &#39;请输入身份证号码&#39;, trigger: &#39;blur&#39;&#125;, &#123; pattern: &#x2F;(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)&#x2F;, message: &#39;身份证号码格式不正确&#39;, trigger: &#39;blur&#39; &#125;],｝ 后端验证1.普通校验添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 在resources目录下创建校验出错时的提示文件ValidationMessages.properties 12345user.name.size&#x3D;用户名长度介于5到10个字符之间user.address.notnull&#x3D;用户地址不能为空user.age.size&#x3D;年龄输入不正确user.email.notnull&#x3D;邮箱不能为空user.email.pattern&#x3D;邮箱格式不正确 实体类 1234567891011121314public class User &#123; private Integer id; @Size(min &#x3D; 5,max &#x3D; 10,message &#x3D; &quot;&#123;user.name.size&#125;&quot;) private String name; @NotNull(message &#x3D; &quot;&#123;user.address.notnull&#125;&quot;) private String address; @DecimalMin(value &#x3D; &quot;1&quot;,message &#x3D; &quot;&#123;user.age.size&#125;&quot;) @DecimalMax(value &#x3D; &quot;200&quot;,message &#x3D; &quot;&#123;user.age.size&#125;&quot;) private Integer age; @Email(message &#x3D; &quot;&#123;user.email.pattern&#125;&quot;) @NotNull(message &#x3D; &quot;&#123;user.email.notnull&#125;&quot;) private String email; &#x2F;&#x2F;省略getter&#x2F;setter &#125; UserController使用@Validated 1234567@RestControllerpublic class UserController &#123; @PostMapping(&quot;&#x2F;user&quot;) public List&lt;String&gt; addUser(@Validated User user)&#123; &#x2F;&#x2F;... &#125;&#125; 2.分组校验… 3.校验注解Spring Boot Validation校验注解参考表","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离4--controller请求注解与前后端参数传递","date":"2019-12-30T03:23:10.000Z","path":"2019/12/30/springboot+vue前后端分离4--controller请求注解与前后端参数传递/","text":"controller请求注解与前后端参数传递1. 注解@Getmapping@GetMapping： 处理get请求，传统的RequestMapping来编写应该是 1@RequestMapping(value &#x3D; “&#x2F;get&#x2F;&#123;id&#125;”, method &#x3D; RequestMethod.GET) 新方法可以简写为： 1@GetMapping(&quot;&#x2F;get&#x2F;&#123;id&#125;&quot;) @PostMapping@PostMapping： 处理post请求，传统的RequestMapping来编写应该是 1@RequestMapping(value &#x3D; “&#x2F;get&#x2F;&#123;id&#125;”,method &#x3D; RequestMethod.POST) 新方法可以简写为： 1@PostMapping(&quot;&#x2F;get&#x2F;&#123;id&#125;&quot;) @PutMapping@PutMapping： 和PostMapping作用等同，都是用来向服务器提交信息。如果是添加信息，倾向于用@PostMapping，如果是更新信息，倾向于用@PutMapping。两者差别不是很明显。 1234567@PutMapping(&quot;&#x2F;&quot;)public RespBean updatePosition(@RequestBody Position position) &#123; if (positionService.updatePosition(position) &#x3D;&#x3D; 1) &#123; return RespBean.ok(&quot;更新成功&quot;); &#125; return RespBean.error(&quot;更新失败&quot;);&#125; @DeleteMapping删除URL映射 1234567@DeleteMapping(\"/&#123;id&#125;\")public RespBean deletePosition(@PathVariable Integer id)&#123; if (positionService.deletePosition(id) == 1) &#123; return RespBean.ok(\"删除成功\"); &#125; return RespBean.error(\"删除失败\");&#125; 2. 前传后–参数传递对接@RequestParam@RequestParam 支持下面四种参数 defaultValue 如果本次请求没有携带这个参数，或者参数为空，那么就会启用默认值 name 绑定本次参数的名称，要跟URL上面的一样 required 这个参数是不是必须的 value 跟name一样的作用，是name属性的一个别名 前端请求 1this.getRequest(&quot;&#x2F;employee&#x2F;basic&#x2F;?page&#x3D;&quot; + this.page + &quot;&amp;size&#x3D;&quot; + this.size + &quot;&amp;keywords&#x3D;&quot; + this.keywords) 后端对接 12345678@RequestMapping(\"/employee/basic\")public class EmpBasicController &#123;...@GetMapping(\"/\") public RespPageBean getEmployeeByPage(@RequestParam(defaultValue = \"1\") Integer page, @RequestParam(defaultValue = \"10\") Integer size, String keywords) &#123; ... &#125;&#125; @PathVariable@PathVariable 根据URL模板读取URL中的参数前端请求 1this.deleteRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot; + data.id) 后端对接 12345678@RequestMapping(&quot;&#x2F;system&#x2F;basic&#x2F;pos&quot;)public class PositionController &#123;... @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;) public RespBean deletePosition(@PathVariable Integer id)&#123; ... &#125;&#125; @RequestBody@RequestBody 一般情况下来说常用其来处理application/json类型前端请求 123456789data()&#123; return&#123; pos: &#123; name: &#39;添加的JSON数据&#39; &#125;, &#125;&#125; this.postRequest(&quot;&#x2F;system&#x2F;basic&#x2F;pos&#x2F;&quot;, this.pos) 后端对接 12345678@RequestMapping(&quot;&#x2F;system&#x2F;basic&#x2F;pos&quot;)public class PositionController &#123;... @PostMapping(&quot;&#x2F;&quot;) public RespBean addPosition(@RequestBody Position position) &#123; ... &#125;&#125; 3. 后传前–注解@JsonIgnore@JsonIgnore 在实体类向前台返回数据时用来忽略不想传递给前台的属性或接口例子：User实体中会有字段password字段，当返回用户信息给前台的时候，当然是不希望将password值也一并返回。所以，这个时候可以在password属性上加上注解JsonIgnore 12345678public class User &#123; private Integer id; private String name; private String username; private Date birthday; @JsonIgnore private String password;&#125; @JsonFormat@JsonFormat(pattern=”yyyy-MM-dd”,timezone = “GMT+8”) pattern：是你需要转换的时间日期的格式 timezone：是时间设置为东八区，避免时间在转换中有误差 提示：@JsonFormat注解可以在属性的上方，同样可以在属性对应的get方法上，两种方式没有区别 123456789public class User &#123; private Integer id; private String name; private String username; @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"Asia/Shanghai\") private Date birthday; @JsonIgnore private String password;&#125; 12345@GetMapping(\"/Users/\")@JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"Asia/Shanghai\")public List&lt;User&gt; getAllUsers()&#123; ...&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离3--前端动态路由配置","date":"2019-12-27T08:23:10.000Z","path":"2019/12/27/springboot+vue前后端分离3--前端动态路由配置/","text":"前端动态路由配置1. Vuex状态管理详情见官方文档 Vuex 是什么？ 创建src/store/index.js将服务端返回的JSON数据保存到store中，然后各个Vue页面根据store中的数据来渲染菜单 index.js 123456789101112131415161718192021import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; //定义变量 state:&#123; routes:[], &#125;, //更改状态的方法 mutations:&#123; initRoutes(state,data)&#123; state.routes = data; &#125; &#125;, //向mutations异步提交更改方法 actions:&#123; &#125;&#125;) 在main.js中引入 1234567import router from './router'new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app') 2. 动态路由实现–菜单请求工具类封装需求需要将请求menu JSON数据格式123456789101112131415161718192021222324252627282930313233[&#123; &quot;id&quot;: 2, &quot;url&quot;: &quot;&#x2F;&quot;, &quot;path&quot;: &quot;&#x2F;home&quot;, &quot;component&quot;: &quot;Home&quot;, &quot;name&quot;: &quot;员工资料&quot;, &quot;iconcls&quot;: &quot;fa fa-user-circle-o&quot;, &quot;meta&quot;: &#123; &quot;keepalive&quot;: null, &quot;requireauth&quot;: true &#125;, &quot;parentid&quot;: 1, &quot;enabled&quot;: true, &quot;children&quot;: [ &#123; &quot;id&quot;: 7, &quot;url&quot;: null, &quot;path&quot;: &quot;&#x2F;emp&#x2F;basic&quot;, &quot;component&quot;: &quot;EmpBasic&quot;, &quot;name&quot;: &quot;基本资料&quot;, &quot;iconcls&quot;: null, &quot;meta&quot;: &#123; &quot;keepalive&quot;: null, &quot;requireauth&quot;: true &#125;, &quot;parentid&quot;: 2, &quot;enabled&quot;: true, &quot;children&quot;: null, &quot;roles&quot;: null &#125; ], &quot;roles&quot;: null &#125;,] 转化成router所需的数据格式 1234567891011&#123; path: &#39;&#x2F;home&#39;, name: &#39;员工资料&#39;, component: Home, children:[ &#123; path: &#39;&#x2F;emp&#x2F;basic&#39;, name: &#39;基本资料&#39;, component: resolve &#x3D;&gt; require([&#39;..&#x2F;views&#x2F;emp&#x2F;EmpBasic.vue&#39;], resolve), &#125;,&#125; 其中路由懒加载的一种写法1component: resolve &#x3D;&gt; require([&#39;..&#x2F;views&#x2F;emp&#x2F;EmpBasic.vue&#39;], resolve), 也可以写成参考Vue官方文档-路由懒加载1component: () &#x3D;&gt; import(&#39;..&#x2F;pages&#x2F;home.vue&#39;), 方法创建工具类src/utils/menus.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123;getRequest&#125; from &quot;.&#x2F;api&quot;;&#x2F;&#x2F;加载菜单数据方法export const initMenu &#x3D; (router, store) &#x3D;&gt; &#123; &#x2F;&#x2F;如果有数据则不加载 if (store.state.routes.length &gt; 0) &#123; return; &#125; &#x2F;&#x2F;无数据则请求菜单数据 getRequest(&quot;&#x2F;system&#x2F;config&#x2F;menu&quot;).then(data &#x3D;&gt; &#123; if (data) &#123; let fmtRoutes &#x3D; formatRoutes(data); router.addRoutes(fmtRoutes); store.commit(&#39;initRoutes&#39;, fmtRoutes); &#125; &#125;)&#125;&#x2F;&#x2F;创建JSON数据格式处理方法export const formatRoutes &#x3D; (routes) &#x3D;&gt; &#123; let fmRoutes &#x3D; []; routes.forEach(router &#x3D;&gt; &#123; &#x2F;&#x2F;批量定义 let path &#x3D; router.path ... let &#123; path, component, name, meta, iconcls, children &#125; &#x3D; router; &#x2F;&#x2F;如果有子菜单且满足子菜单为数组 children为空表示无子菜单 &#x2F;&#x2F;递归调用 if (children &amp;&amp; children instanceof Array) &#123; children &#x3D; formatRoutes(children); &#125; let fmRouter &#x3D; &#123; path: path, name: name, iconcls: iconcls, meta: meta, children: children, &#x2F;&#x2F;动态加载component的值 component(resolve) &#123; if (component.startsWith(&quot;Home&quot;)) &#123; &#x2F;&#x2F;component: resolve &#x3D;&gt; require([&#39;..&#x2F;views&#x2F;emp&#x2F;EmpBasic.vue&#39;], resolve), require([&#39;..&#x2F;views&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; else if (component.startsWith(&quot;Emp&quot;)) &#123; require([&#39;..&#x2F;views&#x2F;emp&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; else if (component.startsWith(&quot;Per&quot;)) &#123; require([&#39;..&#x2F;views&#x2F;per&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; else if (component.startsWith(&quot;Sal&quot;)) &#123; require([&#39;..&#x2F;views&#x2F;sal&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; else if (component.startsWith(&quot;Sta&quot;)) &#123; require([&#39;..&#x2F;views&#x2F;sta&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; else if (component.startsWith(&quot;Sys&quot;)) &#123; require([&#39;..&#x2F;views&#x2F;sys&#x2F;&#39; + component + &#39;.vue&#39;], resolve); &#125; &#125; &#125; fmRoutes.push(fmRouter); &#125;) return fmRoutes;&#125; 3. 动态路由实现–路由全局前置守卫详情路由全局前置守卫main.js 123456789101112131415router.beforeEach((to,from,next)=&gt;&#123; //去login页则通过 去其他页面判断是否登录 if (to.path =='/')&#123; next(); &#125;else &#123; //根据自己编写的登录后用户保存在哪 则从哪调用 if (window.sessionStorage.getItem(\"user\"))&#123; initMenu(router,store); next(); &#125;else &#123; next('/?Redirect='+to.path); &#125; &#125;&#125;)","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离2--前后端对接","date":"2019-12-26T06:32:32.000Z","path":"2019/12/26/springboot+vue前后端分离2--前后端对接/","text":"前段工具类api.js1. 安装axios请求工具1npm install axios 2. 对响应以及请求方法进行工具类封装2.1 响应状态处理通过axios响应拦截器、element的message 对响应状态进行处理创建src/utils/api.js 123456789101112131415161718192021222324252627282930import axios from &#39;axios&#39;import &#123;Message&#125; from &quot;element-ui&quot;;&#x2F;&#x2F; axios响应拦截器axios.interceptors.response.use(success &#x3D;&gt; &#123; if (success.status &amp;&amp; success.status &#x3D;&#x3D; 200 &amp;&amp; success.data.status &#x3D;&#x3D; 500) &#123; Message.error(&#123;message: success.data.msg&#125;) return; &#125; if (success.data.msg) &#123; Message.success(&#123;message: success.data.msg&#125;) &#125; return success.data;&#125;, error &#x3D;&gt; &#123; if (error.response.status &#x3D;&#x3D; 504 || error.response.status &#x3D;&#x3D; 404) &#123; Message.error(&#123;message: &#39;服务器被吃了( ╯□╰ )&#39;&#125;) &#125; else if (error.response.status &#x3D;&#x3D; 403) &#123; Message.error(&#123;message: &#39;权限不足，请联系管理员&#39;&#125;) &#125; else if (error.response.status &#x3D;&#x3D; 401) &#123; Message.error(&#123;message: &#39;尚未登录，请登录&#39;&#125;) router.replace(&#39;&#x2F;&#39;) &#125; else &#123; if (error.response.data.msg) &#123; Message.error(&#123;message: error.response.data.msg&#125;) &#125; else &#123; Message.error(&#123;message: &#39;未知错误!&#39;&#125;) &#125; &#125; return;&#125;) 2.2 请求方法封装api.js使用时在使用处import {postKeyValueRequest} from ...即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;&#x2F;url前缀let base &#x3D; &#39;&#39;;export const postKeyValueRequest &#x3D; (url, params) &#x3D;&gt; &#123; return axios(&#123; method: &#39;post&#39;, url: &#96;$&#123;base&#125;$&#123;url&#125;&#96;, data: params, transformRequest: [function (data) &#123; let ret &#x3D; &#39;&#39;; for (let i in data) &#123; ret +&#x3D; encodeURIComponent(i) + &#39;&#x3D;&#39; + encodeURIComponent(data[i]) + &#39;&amp;&#39; &#125; return ret; &#125;], headers: &#123; &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39; &#125; &#125;);&#125;export const postRequest&#x3D;(url,params)&#x3D;&gt;&#123; return axios(&#123; method: &#39;post&#39;, url:&#96;$&#123;base&#125;$&#123;url&#125;&#96;, data:params, &#125;)&#125;export const putRequest&#x3D;(url,params)&#x3D;&gt;&#123; return axios(&#123; method: &#39;put&#39;, url:&#96;$&#123;base&#125;$&#123;url&#125;&#96;, data:params, &#125;)&#125;export const getRequest&#x3D;(url,params)&#x3D;&gt;&#123; return axios(&#123; method: &#39;get&#39;, url:&#96;$&#123;base&#125;$&#123;url&#125;&#96;, data:params, &#125;)&#125;export const deleteRequest&#x3D;(url,params)&#x3D;&gt;&#123; return axios(&#123; method: &#39;delete&#39;, url:&#96;$&#123;base&#125;$&#123;url&#125;&#96;, data:params, &#125;)&#125; 示例main.js 1234567891011import &#123;postRequest&#125; from &quot;.&#x2F;utils&#x2F;api&quot;;import &#123;putRequest&#125; from &quot;.&#x2F;utils&#x2F;api&quot;;import &#123;getRequest&#125; from &quot;.&#x2F;utils&#x2F;api&quot;;import &#123;deleteRequest&#125; from &quot;.&#x2F;utils&#x2F;api&quot;;import &#123;postKeyValueRequest&#125; from &quot;.&#x2F;utils&#x2F;api&quot;;Vue.prototype.postRequest &#x3D; postRequest;Vue.prototype.putRequest &#x3D; putRequest;Vue.prototype.getRequest &#x3D; getRequest;Vue.prototype.deleteRequest &#x3D; deleteRequest;Vue.prototype.postKeyValueRequest &#x3D; postKeyValueRequest; 配置请求转发创建vue.config.js在src下将请求8080转发到8081 1234567891011121314151617let proxyObj &#x3D; &#123;&#125;;proxyObj[&#39;&#x2F;&#39;] &#x3D; &#123; ws:false, target:&#39;http:&#x2F;&#x2F;localhost:8081&#39;, changeOrigin: true, pathRewrite:&#123; &#39;^&#x2F;&#39; :&#39;&#39;, &#125;&#125;module.exports&#x3D;&#123; devServer:&#123; host:&#39;localhost&#39;, port:8080, proxy:proxyObj, &#125;&#125;","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]},{"title":"springboot+vue前后端分离1--项目搭建","date":"2019-12-25T13:35:22.000Z","path":"2019/12/25/springboot+vue前后端分离1--项目搭建/","text":"项目搭建1. 前段项目构建使用vue-cli3构建代码: 1234npm install -g vue-clivue create vuehrcd vuehrnpm run dev vue-cli2.x创建项目是vue init hello-world或者使用Webstorm直接创建选择自主定制 加入router、vuex等 2. Element UI 安装及引入1.npm安装 1npm i element-ui -S 2.完整引入在 main.js 中写入以下内容： 1234567891011import Vue from 'vue';import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';import App from './App.vue';Vue.use(ElementUI);new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;); 将App.vue留下 &lt;router-view/&gt; 123456789&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 3. 后端项目构建用idea创建springboot项目后 pom.xml加入druid、mysql、generator123456789101112131415161718192021222324252627282930 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.29&lt;/version&gt; &lt;/dependency&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件--&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--允许覆盖生成的文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置application.properties1234567spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=mysql@123spring.datasource.url=jdbc:mysql:///vhr?useUnicode=true&amp;characterEncoding=utf-8server.port=8081 数据库逆向工程 方法一：使用 EasyCode 进行数据库逆向工程详细步骤=》EasyCode懒人必备，IntelliJIDEA中代码一键生成 方法二：使用generator3个必备文件 generator.properties generatorConfig.xml的配置数据源文件jdbc.properties 放在resources目录下 generator.properties 1234567891011121314151617driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/vhr?useUnicode=true&amp;characterEncoding=utf-8username=rootpassword=mysql@123#entity 包名和 java目录modelPackage=com.tsune.entitymodelProject=src/main/java#sqlmap包名 和resources目录sqlPackage=sqlmappersqlProject=src/main/resources#mapper包名和 java目录mapperPackage=com.tsune.daomapperProject=src/main/javaschema=vhrtable=% generatorConfig.xml注意修改项目的 mysql-connector-java 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置 --&gt; &lt;properties resource=\"generator.properties\"/&gt; &lt;!-- 项目的 mysql-connector-java --&gt; &lt;classPathEntry location=\"C:\\Users\\TsuNe\\.m2\\repository\\mysql\\mysql-connector-java\\5.1.29\\mysql-connector-java-5.1.29.jar\" /&gt; &lt;context id=\"context1\"&gt; &lt;!-- 注释 --&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt;&lt;!-- 是否取消注释 --&gt; &lt;property name=\"suppressDate\" value=\"true\" /&gt; &lt;!-- 是否生成注释代时间戳 --&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass=\"$&#123;driver&#125;\" connectionURL=\"$&#123;url&#125;\" userId=\"$&#123;username&#125;\" password=\"$&#123;password&#125;\" /&gt; &lt;!-- 类型转换 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage=\"$&#123;modelPackage&#125;\" targetProject=\"$&#123;modelProject&#125;\" /&gt; &lt;sqlMapGenerator targetPackage=\"$&#123;sqlPackage&#125;\" targetProject=\"$&#123;sqlProject&#125;\" /&gt; &lt;javaClientGenerator targetPackage=\"$&#123;mapperPackage&#125;\" targetProject=\"$&#123;mapperProject&#125;\" type=\"XMLMAPPER\" /&gt; &lt;!-- 如果需要通配所有表 直接用sql的通配符 %即可 --&gt; &lt;table schema=\"$&#123;schema&#125;\" tableName=\"$&#123;table&#125;\" /&gt;&lt;!-- enableCountByExample=\"false\"--&gt;&lt;!-- enableUpdateByExample=\"false\" enableDeleteByExample=\"false\"--&gt;&lt;!-- enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; generatorConfig.xml的配置数据源文件jdbc.properties 12345678910111213141516driver=com.mysql.jdbc.Driver#mytest为我本地的数据库名url=jdbc:mysql://localhost:3306/vhr?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=falseusername=root#下面输入自己数据库的密码password=mysql@123#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 配置@MapperScan(basePackages = “com.tsune.vhr02.dao”)作用：指定要变成实现类的接口所在的包，然后包下面的所有接口在编译之后都会生成相应的实现类添加位置：是在Springboot启动类上面添加 Vhr02Application 123456789@SpringBootApplication@MapperScan(basePackages = \"com.tsune.vhr02.dao\")public class Vhr02Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Vhr02Application.class, args); &#125;&#125; pom.xml 1234567891011&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 详情 Spring boot整合mybatis.xml资源文件放置及路径配置问题","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://yoursite.com/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}]}]